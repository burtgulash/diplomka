\documentclass[11pt,letterpaper,oneside,openright]{book}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage{a4wide}
\usepackage{hyperref}
\usepackage[bottom=2.8cm]{geometry}
\usepackage{color}
\usepackage[numbers]{natbib}
\usepackage[scaled=0.83]{beramono}

\pagestyle{plain}
\linespread{1.15}

\definecolor{Darkgreen}{rgb}{0,0.4,0}
\hypersetup{%
    pdfborder={0 0 0},
    colorlinks,
    citecolor=blue,
    filecolor=blue,
    linkcolor=blue,
    urlcolor=Darkgreen
}

% \usepackage{sectsty}
% \sectionfont{\fontsize{21}{21}\selectfont}
% \subsectionfont{\fontsize{16}{16}\selectfont}
% \subsubsectionfont{\fontsize{14}{14}\selectfont}

\makeatletter
\def\@makechapterhead#1{%
    \vspace*{30pt}%
    {\parindent 0pt \raggedright \normalfont
        \interlinepenalty=-1
        \Huge \bfseries \thechapter\hspace{.75em}#1\par\nobreak
        \vskip 40pt
    }}
\makeatother

\newcommand{\bftt}[1]{\texttt{\textbf{#1}}}
\newcommand{\boldred}[1]{\textbf{\color{red} #1}}


\begin{document}
\frontmatter
{\hypersetup{hidelinks}
    \tableofcontents
}

\mainmatter
\chapter{Úvod}
Díky vzestupu počítačů a především internetu došlo k dramatickému nárustu
objemu textových informací ve formě snadno přístupné lidem i pro počítačové
zpracování. Textová data jsou specifická v tom, že jejími tvůrci jsou lidé a ne
počítačové systémy nebo měřící čidla. Při vyhledávání v takovýchto datech máme
jako lidé silná očekávání na relevanci výsledků vyhledávání, nicméně kvůli
charakteristice textových dat je vyhledávání v nich obtížné. Tím, že je úkol
obtížný, existuje více specifických zaměření, než jedno obecné a použitelné pro
všechny případy.

S nástupem World Wide Webu v 90. letech došlo k vzestupu Webových vyhledávačů,
které dnes slouží jako vstupní brána do světa informací.
...

V této práci se snažím najít alternativní způsoby v tomto širokém oboru, které
nejsou velmi známé, a zaměřím se na oblast, která je dle mého názoru jednou z
nejžádanějších v praktických aplikacích. V současné době se pro ni ale
používají techniky pro příliš obecné a zdrojově náročné prohledávání Webu a
nedosahují takových výsledků, jakých by mohly, nebo za příliš vysokou cenu
komplikovaných řešení.

Velkým důvodem proč převažují techniky pro Webové vyhledávání je psychologický
- většina problémů, se kterými se potýkají firmy i nekomerční projekty, zdaleka
nepracuje s takovými objemy dat, se kterým se musí potýkat rozsáhlé webové
vyhledávače nebo světové sociální sítě. V praxi jsou tyto problémy často
řešitelné s použitím pouze jednoho počítače. Nicméně lidé přehnaně věří, že
jejich projekty budou jednou dosahovat obdobných závratných velikostí, a proto
volí řešení nevhodné pro jejich problémy.

V ideálním případě by měla být podpora pro efektivní textové vyhledávání
zabudována přímo do databázových systémů, ale v současné době není jejich
podpora ideální, a proto aplikace s podporou textového vyhledávání používají
kromě databáze ještě paralelní systém specializovaný pro text. Důvod je ten, že
je obtížné vytvořit vyhledávač v takové formě, aby vyhovoval obecným
požadavkům, na které se databáze používají. Techniky představené v této práci
by měly být vhodnější pro generické účely, než ty, které používají Webové
vyhledávače a ze kterých se čerpá inspirace pro textové indexy vestavěné do
databází.

...

V první části uvedu problém vyhledávání v textu, aby čtenář pochopil z jakého
základu tato práce vychází. V druhé části na současný stav v praktickém světě
textového vyhledávání a jak jsme se do něj dostali. Pak se zaměřím na algoritmy
a datové struktury textového vyhledávání a alternativní techniky, které jsou v
některých případech exotické a nepříliš vhodné na obecné použití, ale jiné
které by dle mého názoru zasloužily větší pozornost, protože jejich zaměření
odpovídá současným potřebám více, než na které je v dnešní době kladen největší
důraz. V další části rozeberu vybranou oblast textového vyhledávání více do
hloubky a popíšu problémy, které se v ní vyskytují. Zároveň rozeberu jejich
řešení různými výzkumnými týmy a můj návrh na řešení. V sekci Analýza
kvantitativně poukážu na konkrétní problémy popsané v předchozí sekci a
problémy implementace takového systému. Na závěr představím možná budoucí
řešení a další kroky k vylepšení, aby bylo možné vyhledávací systém nasadit v
praxi.

\chapter{Motivace}

\subsubsection{Databáze a textové vyhledávání}
Textové vyhledávání se často uvádí odděleně od databázových systémů, přestože
by v ideálním případě mělo být součástí databází. Důvodem je silně různorodá
povaha textových dat s nejednoznačným způsobem zacházení. Pokud v databázích
pracujeme například s čísly, pak je situace celkem snadná, protože čísla jsou
snadno a jednoznačně porovnatelná, ať už to jsou floating nebo celá čísla. Díky
seřaditelnosti pak můžeme použít algoritmus binární vyhledávání, nebo
dynamickou obdobu v podobě binárních vyhledávacích stromů.

Jiné datové typy jako třeba intervaly jsou složitější, ale přesto existují
pevně definovatelné způsoby pro jejich seřazení a tedy snadné vyhledávání.
Intervalovými daty mohou být jednorozměrná časová rozmezí, dvourozměrná
geografická data, nebo vícerozměrná data často používaná v počítačové grafice.
Existuje pro ně velké množství relativně efektivních algoritmů a aktivní
výzkum. Časová data jsou na první pohled lehce seřaditelná, jenže kvůli lidským
"obohacením", jako jsou časové zóny, letní čas, nebo více dimenzí času (čas
platnosti, čas záznamu) se jejich zacházení v databázích komplikuje. Textová
data generovaná lidskou řečí jsou ještě komplikovanější a často se řeší mimo
databázové systémy. Ve výsledku používá spousta uživatelských aplikací s
databázovou podporou ve skutečnosti dva systémy - kromě klasické databáze ještě
speciální systém pro relevantní a efektivní textové vyhledávání.

Problém s textem, který nás zajímá, je jeho nejednoznačná seřaditelnost.
Představme si databázi lidských jmen a aplikaci určenou pro vyhledávání v nich.
Počítá se s tím, že pokud vyhledáváme konkrétní osobu, nevíme přesně jak je
její jméno v databázi uloženo. Kdybychom věděli, že se Jaromír Kobliha v
databázi vyskytuje v konkrétním tvaru Jaromír Kobliha nebo Kobliha, Jaromír
nebo Dr. Jarda Kobliha, pak jednoduše zadáme dotaz na přesnou shodu a máme
vyřešeno. Jenže naše očekávání jsou jiná. Člověk by všechny tyto tvary jména
vyhodnotil ekvivalentně, a tím pádem je naším úkolem vytvořit podobně chytrý
systém anebo alespoň iluzi takového systému.

Jména mohou být jednoduše rozdělena na více sloupců - křestní jméno, prostřední
jméno, příjmení, titul(y), tak jak to známe, pokud vyplňujeme kdejaké
formuláře. To umožní systému provést oddělený dotaz v každém tomto sloupci a
sloučit výsledky. Nebo jména seřadit nejprve podle příjmení, pak podle jména a
titulů naposled (Kobliha, Jaromír, Dr.), protože předpokládáme, že existuje
méně příjmení než křestních jmen a ještě méně titulů. Tohle je ovšem jenom
heuristika, kterou nelze aplikovat např. ve Vietnamu (Nguyen a Tran tvoří 50\%
všech příjmení) nebo v Jižní Korey (Kim, Lee, Park a Choi tvoří 50\% všech
příjmení). Jiné kultury nemají ani koncept příjmení, proto je takový systém
obecně nedostatečný.

Pro větší záznamy - celé dokumenty o několika stovkách až tisících slov - nelze
ani uvažovat seřaditelnost podobně naivním způsobem. Přestože je vyhledávání v
textu obtížné, existují možnosti, jak povahu lidského textu využít a vytvořit
algoritmy umožňující efektivní vyhledávání.

Statisticky můžeme pozorovat unikátní povahu lidského jazyka v několika statistických pozorováních.
% Frekvenční analýza - codebreaking
% 1, 2,3 - více jedničěk distribuce
% zipf distribuce slov
% redundance - deflate a jiný textový komprese

[1] \url{https://en.wikipedia.org/wiki/Information_retrieval#History}
[1] \url{https://www.theguardian.com/commentisfree/2015/apr/18/google-eu-monopoly-inquiry-too-late-to-stop}


\section{Změny v architekturách počítačů a počítačových systémů}
% Stonebraker o databázích
% sloupcové a in-memory db
% něco o nosql
% hierarchie paměti
% ssd
% nvram

% konvergence db a fulltextu. Podobnost se sloupcovými db. Not yet because of
% reasons below. Columnar dbs for analytical slow access. tens of thousands
% columns needed for each word. If some words have short inverted list, then
% waste,because blocks have minimum size.

\subsubsection{Nové potřeby ve vyhledávání}
\subsubsection{Vertikální vyhledávání}
Dle hlavního vedoucího výzkumu v Googlu, Petera Norviga, je úspěch Googlu
založen ne na lepších algoritmech, než by měli ostatní, ale jednoduše tím, že
má více dat.
% přístup googlu - chytré scrapování. Přitom data existují ve zpracované formě.
% Nedostatek vertikálního a site search? Špatné nebo obtížné open source
% řešení?
\subsubsection{Linked data}
\subsubsection{Mobilní zařízení}



\section{Textové vyhledávání}
Vstupem v úloze vyhledávání je \textbf{dotaz} (query), tedy vstupní textový
řetězec. Výstupem je seznam odpovídajících záznamů (dokumentů) z databáze
seřazený podle ohodnocení, kterou vyhledávací systém přiřadí dle shody
(relevance) dotazu s nalezeným záznamem.

Pokud by dotazem bylo například jediné slovo \bftt{Petr}, mohl by výsledek
vyhledávání v databázi jmen vrátit jména \bftt{Petr Novák, Petr Novotný, Petr
Klíč, Petr Žel, ...}. Dotazem je povětšinou posloupnost jednoho nebo více slov,
ale může obsahovat i různé operátory, které upravují povahu dotazu. Například
booleovské operátory AND, OR a NOT mohou určit zda se musí shodovat všechna
slova, nebo pouze jedno, nebo se slovo vyskytovat nesmí. Např. dotaz
\bftt{Pavel OR Petr AND NOT Novák}. Každý vyhledavač implementuje různé
operátory a kromě těch základních booleovských nejsou jejich funkce nijak
sjednoceny.

Uživatelsky jsou nejpřívětivější vyhledávače, u kterých není třeba speciální
operátory vůbec používat. Vyhledávač si je buďto sami doplní do čistě textového
dotazu, nebo se o vysokou přesnost postarají jejich hodnotící funkce.

\subsubsection{Relevance}
Pro měření relevance existují dvě základní metriky - přesnost (precision) a
výtěžnost (recall) \url{https://wiki.korpus.cz/doku.php/pojmy:precision}.

Přesnost je poměr počtu relevantních nalezených výsledků ku počtu všech
nalezených výsledků. Tedy vyhledávač bude vyhledávat přesně, pokud bude
obsahovat malé množství výsledků¸ které s dotazem nemají nic společného.
Vyhledávače cílící na přesnost ale mohou trpět tím, že některé záznamy, které
jsou pro uživatele relevantní, nejsou vůbec nalezeny. To měří právě výtěžnost -
tedy poměr počtu relevantních nalezených výsledků ku počtu všech relevantních
záznamů v databázi. Pro relevantní vyhledávání jsou důležité obě hodnoty. Při
malé výtěžnosti bude uživatel cítit frustraci z toho, že musí hloupému
vyhledávači podstrčit více podobných dotazů a stále bude mít pocit, že
vyhledávač nenalezl všechno. Při malé přesnosti bude mít uživatel pocit, že si
vyhledávač vyhledává, co se mu zlíbí.

U relativně malých datových sad, kterými se tato práce zabývá, je narozdíl od
webových vyhledávačů velmi důležitá výtěžnost. Při velkém množství výsledků se
ztratí, že některé dokumenty nebudou nalezeny. V databázi jmen by ale bylo
velmi frustrující, kdyby při dotazu \bftt{Jan Voštěp} nebylo nic nalezeno,
přitom by v databázi existoval záznam \bftt{Dr. Voštěp, Jan}.

\subsubsection{Invertovaný index}
Centrální datovou strukturou, která navíc využívá ve svůj prospěch Zipfovy
distribuce slov, je datová struktura \textbf{invertovaný index} (nebo také
invertovaný soubor). Princip datové struktury je ten, že pro každé slovo, které
se vyskytuje v databázi, si uložíme seznam odkazů na všechny záznamy
(dokumenty), na kterých se slovo nachází.  Invertovaný index by měl být znám
všem, kdo čtou knihy, protože rejstřík na posledních stránkách není ničím jiným
než právě invertovaným indexem, kde jedním záznamem je stránka knihy a odkazem
je číslo stránky.

Invertovaný index jsou ve skutečnosti dvě datové struktury. Tou první je
takzvaný slovník - tedy seznam všech vyskytujících se slov s odkazem na svůj
příslušný seznam odkazů, neboli invertovaný seznam. Druhou strukturou je
samotný invertovaný soubor, což je soubor všech invertovaných seznamů.

Obě datové struktury mohou být implementovány různými způsoby podle druhu
použití a požadovaných vlastností. Kupříkladu obyčejná hashovací tabulka
poskytne velmi rychlý přístup k hledanému slovu ve slovníku, ale bude zabírat
relativně mnoho paměti, protože každý záznam v tabulce si musí uchovat samotný
text uloženého slova. V textovém vyhledávání, které často pracuje s velkými
objemy dat, bude vhodnější pouhý seřazený seznam slov, na který lze použít
binární vyhledávání. Odpadne nutnost ukládat pomocná data hashovací tabulky a
navíc lze použít jednoduchou kompresní metodu - tzv. front coding. Pořadí slova
v seřazeném seznamu lze použít jako odkaz pro nalezení odpovídajícího
invertovaného seznamu.

Invertovaný index je datová struktura obzvlášť obtížná na úpravy, protože je v
paměti počítače uchována ve velmi kompaktní formě - často s použitím dalších
kompresních algoritmů. Právě díky tomu na druhou stranu dosahuje vyšší
rychlosti čtení oproti obecným vyhledávacím stromům. Index se proto často
nejprve vytvoří (\textbf{indexování}) a pak se používá jen pro čtení.

%\vspace{1cm}
%Příklad:
%
%\begin{center}
%\begin{tabular}{lr}
%\textbf{slovo}   & \textbf{ukazatel} \\
%\hline
%anderson          & 3  \\
%andrea            & 4  \\
%andulka           & 1  \\
%andy              & 2  \\
%kajak             & 13 \\
%kamna             & 14 \\
%karafiol          & 6  \\
%karate            & 12 \\
%karburátor        & 7  \\
%karel             & 11 \\
%karkulka          & 5  \\
%karma             & 8  \\
%karta             & 9  \\
%karty             & 10 \\
%\end{tabular}
%\end{center}

Pro ještě kompaktnější uložení se používá kompresní technika Front-Coding,
která využívá toho, že po sobě následující slova sdílí prefixy. Slovník se
rozdělí na bloky o konstantním počtu slov a prefix se pro tento blok uloží
zvlášť. Například při použití velikosti bloku 4 by slovník se slovy
\bftt{anderson, andrea, andulka, andy, kajak, kamna, karafiol, karate,
karburátor, karel, karkulka, karma, karta, karty} vypadal:
\bftt{\{and\}erson, rea, ulka, y | \{ka\}jak, mna, rafiol, rate | \{kar\}burátor, el, kulka, ma | \{kart\}a, y}

% TODO ukázka invertovaného indexu

\subsubsection{Alternativní datové struktury}
Invertovaný index je stále nejefektivnější datovou strukturou pro vyhledávání v
textu, ale pro některé speciální případy byly navrženy i jiné datové struktury,
které dokáží být kompaktnější než invertovaný index po kompresi, nebo umožňují
vícero seřazení při jednom uložení v paměti. Klasický invertovaný index má
právě jedno seřazení dokumentů - nejčastěji podle vzrůstajícího id dokumentu.

Waweletové stromy - dual sorted Index Treap Index

Obě tyto alternativní datové struktury dosahují obrovských úspor díky
své kompresibilitě, čehož bychom využili, pokud bychom uvažovali
rozsáhlá vstupní data. Ale protože se zaměřuji na relativně malé objemy
dat, avšak s vysokou redundancí při prohledávání, nevyužiji tyto datové
struktury. Dalším velkým důvodem je, že jsem nenašel žádný výzkum, který
by je aplikoval na prefixové, natož přibližné vyhledávání. Na druhou
stranu existuje více výzkumných týmů, kteří se zabývají přibližným
(fuzzy) prohledáváním na modifikovaném invertovaném indexu.

\section{Techniky pro zvýšení relevance}
Vyhledávání v čistém invertovaném indexu je náchylné k neposkytování všech
výsledků. Velkou příčinou ve webových vyhledávačích vždy byla morfologie jazyka
textu. Dokumenty také mohou obsahovat slova jiného jazyka, který uživatel
příliš neovládá, nebo pouze neví, jak se slovo píše. V případě češtiny to není
takový problém díky podobnosti psaní a výslovnosti (vysoká fonémická
ortografie), ale např. v angličtině se mohou různá slova psát při stejné
výslovnosti různě (red - read, clothes - close, steal - steel) nebo naopak
vyslovovat různě při stejném zápisu (lead - olovo nebo vést). Problémem mohou
být i technické pojmy nebo názvy ( ASUS GTX950-2G, 2GB GDDR5 (grafická karta);
ADATA XPG Z1 8GB (2x4GB) DDR4 2133 CL13 (paměť DRAM); ETA 0028 90040 Gratus Max
(Kuchyňský robot)). V dnešní době to mohou být stále více se zvýšeným
používáním mobilních zařízení (a obtížnějším zadáváním textu) překlepy v
dotazu.

\subsubsection{Jazyková analýza}
Velkým problémem textových vyhledávačů je tvarosloví jazyka (morfologie - různé
tvary slov, např. dobrý, dobrou, dobrému, dobrých).  Například při dotazování vyhledávače
na výraz \bftt{motorová pila} nás jistě budou zajímat i výsledky, které
obsahují text \bftt{motorové pile} nebo \bftt{motorových pilách}. Nelze po
uživateli požadovat, aby vyjmenoval všechny tvary slov, které zadává.

V češtině a v dalších indoevropských jazycích dochází k nejvíce morfologickým
změnám na koncích slov.  Klasickým řešením je před indexováním dat provést
jazykovou analýzu a převést slova na kmenový tvar (stematizace). Ve výsledku se
místo slova \bftt{motorových} zaindexuje slovo \bftt{motor} a poté při
vyhledávání se provede tatáž konverze dotazovaných slov. Vyhledávač by tedy
původní výraz \bftt{motorová pila} nejprve převedl na \bftt{motor pil} a
vykonal dotaz s tímto modifikovaným výrazem. Co se považuje za kmen slova je
určeno vybraným algoritmem. Kromě stematizace existuje ještě technika
lemmatizace, která místo kmenu slova hledá jeho základní (slovníkový) tvar.

V jazykové analýze existuje mnoho problémů. Především je závislá na konkrétním
jazyce. Může se stát, že některé datové kolekce obsahují záznamy ve více
jazycích. Pokud je text dostatečně dlouhý nebo obsahuje znaky specifické jen
pro daný jazyk, lze jazyk záznamu detekovat frekvenční analýzou před
morfologickým rozborem. V jiném případě může datová sada obsahovat záznamy v
jednom jazyce, ale jednotlivá slova mohou být v jiném. Pak jednoduchá
frekvenční analýza nebude dostačovat a museli bychom zvolit složitější techniky
pro jazykový rozbor, které jsou ale mimo rozsah této práce.

Problém s lemmatizací je také nejednoznačnost základního tvaru. Například slovo
\bftt{tancích} může mít základní tvar \bftt{tank} nebo \bftt{tanec} podle
významu slova, který by člověk určil z kontextu věty.

\url{https://is.muni.cz/th/256499/fi_m/thesis_sikora.txt}

% Aglutinativní jazyky
\subsubsection{Ngramy}
Alternativou k invertovaným indexům, kde invertovaný seznam odpovídá jednomu
lidskému slovu, jsou tzv. ngramové (qgram?) invertované indexy. Ngramem je
posloupnost několika po sobě jdoucích písmen o konstantní velikosti $n$.  Slovo
\bftt{motorka} obsahuje trigramy (ngram, kde $n = 3$) \bftt{mot, oto, tor,
ork, rka}.  Ngramový invertovaný index by pak měl invertovaný seznam pro každý
nalezený ngram. Velikou výhodu oproti slovnímu indexu je jazyková nezávislost a
podpora přibližného vyhledávání.

% TODO describe trigram indexes

Databázový systém postgres podporuje trigramový index díky jeho univerzálnosti.
\url{https://swtch.com/~rsc/regexp/regexp4.html}


\subsubsection{Inkrementální vyhledávání}
Z pohledu uživatele je velmi přívětivé, pokud se mu dostává zpětné vazby ještě
před tím, než dopíše svůj dotaz. V úplné formě se už během psaní dotazu
objevují první výsledky které by se objevily při potvrzení dotazu (typeahead
search, search as you type, real time search, ...). . Pro velké databáze se
inkrementální vyhledávání nepoužívá kvůli zvýšené výpočetní náročnosti. Namísto
toho se používá slabší forma inkrementálního vyhledávání - našeptávač
(autocompletion), který pouze nabízí uživateli nápovědu na dokončení jeho
dotazu. Pro nápovědu se používaje historie dotazů zadaných všemi uživateli
(query log) a našeptávač vrátí záznam, který maximalizuje podmíněnou
pravděpodobnost \bftt{P(<dotaz>|<nedokončený\_dotaz>)}. Pro relativně malé datové
sady je ale možné použít inkrementální vyhledávání v plné formě za cenu vyšší
zátěže na vyhledávač. Některé systémy to řeší ukládáním průběžných výsledků
nedokončených dotazů do mezipaměti s krátkou žívotností (cite tastier,
completesearch?).

\subsubsection{Prefixové vyhledávání}
V prefixovém inkrementálním vyhledávání uvažujeme, že dotaz, který uživatel v
danou chvíli zadává, je pouze část úplného dotazu. Pokud dokáže vyhledávač
hledat rychleji, než zadavatel píše, pak mu mohou být prezentovány záznamy s
potentiálním dokončeným dotazem prezentovány dříve, než dotaz dopíše. Např.
pokud je dotazem slovo \bftt{motor}, může se stát, že uživatel hledá slovo
\bftt{motorka} a dotaz ještě nedokončil. Pokud dotaz obsahuje více slov, pak
lze vyhledávač nastavit dvěma způsoby. V prvním případě dochází k prefixovému
vyhledávání pouze u posledního slova dotazu, pokud uvažujeme, že uživatel vždy
doplňuje pouze poslední slovo. Druhou variantou je, že umožníme uživateli
vyhledávat každé slovo jako prefix. Výhodou druhé metody z hlediska uživatele
je, že má částečně pod kontrolou morfologické změny slov. Protože k nim dochází
nejčastěji na koncích slov, může uživatel jednoduše vynechat koncovky slov a
vyhledávač mu je doplní. Např. při hledání slova \bftt{motork} by mohly být
nalezeny všechny záznamy obsahující tvary stejného slova (\textbf{motorka,
motorkou, motorkami}) nebo podobných slov (\textbf{motorkem, motorkář}).
Nevýhodou je velká výpočetní náročnost při vyhledávání krátkých prefixů.

\subsubsection{Hranové ngramy} Lze použít techniku hranových ngramů
(edge ngram), které kromě slova samotného zaindexují ještě všechny jeho
prefixy. Např. \bftt{motorka} se rozloží na \bftt{m, mo, mot, moto,
motor, motork, motorka}. Očividně pak i při nedokončeném dotazu
\bftt{moto} systém snadno dohledá úplné slovo. Jednou nevýhodou této
metody je náročnost na paměť - počet zaindexovaných slov i velikost
indexu roste kvadraticky s délkou textu. Proto se často omezuje délka
zaindexovaných hranových ngramů. Krátké ngramy se odfiltrují, protože
jich je příliš mnoho.  Vyhledávání jednoznakového ngramu může být
náročné až jako lineární průchod celou databází. Nevýhodou pak je, že
inkrementální vyhledávání nezačne fungovat už od prvního zadaného
písmene. Dlouhé ngramy se mohou odfiltrovat od maximální zvolené délky
ngramu a obdobná úprava se provede s dotazem. Příklad: indexujeme
hranové ngramy s délkou 2 až 4 znaků. Ze slova \bftt{motorka}
zaindexujeme odpovídající ngramy a celé slovo \bftt{mo, mot, moto,
motorka}. Při dotazu ořízneme slovo na maximální délku, abychom nalezli
shodu s nejdelším ngramem.  Tedy při vyhledávání slova \bftt{motork}
bude vyhledávač hledat záznamy, která obsahují buď \bftt{moto} nebo
\bftt{motorka}.

\subsubsection{Přibližné vyhledávání}
% describe ngrams fuzzy
Jiný způsob kromě ngramů, který umožňuje přibližné vyhledávání, je založený na
textové vzdálenosti mezi dvěma textovými řetězci. Jednoduchou textovou
vzdáleností je Hammingova vzdálenost. Ta se rovná počtu změněných znaků mezi
dvěma texty o stejné délce. Příklad: vzdálenost mezi slovy
\bftt{\boldred{m}oto\boldred{r}ka}, \bftt{\boldred{h}oto\boldred{v}ka} je 2,
protože se slova neshodují ve dvou znacích.

Jinou metrikou je editovací vzdálenost, která není omezená tím, že délka obou
textů musí být shodná. Editovací vzdálenost, stejně jako Hammingova vzdálenost,
udává počet záměn, ale navíc ještě počet odebraných nebo naopak přidaných
znaků. Příklad: Mezi slovy \bftt{kremrole}, \bftt{karel} je editovací
vzdálenost 5, protože slovo \bftt{kre\boldred{mro}l\boldred{e}} obsahuje 4 znaky navíc
a chybí mu 1 znak, který ale slovo \bftt{k\boldred{a}rel} obsahuje.

\section{Prefixové a fuzzy rozšíření indexu}
Ačkoliv se jedná o dva různé požadavky, prefixové a fuzzy invertované indexy
mají ve výsledku podobné vlastnosti a tudíž jsou pro ně vhodné stejné datové
struktury. Pokud na chvíli necháme fuzzy požavky stranou, nastíním, jak lze
jednoduše rozšířit klasický invertovaný index o podporu prefixového
vyhledávání.

Nevýhodou hranových ngramů je, že se může zaindexovat zbytečně mnoho ngramů.
Pokud je paměťová náročnost problém, lze namísto indexování pomocných ngramů
použít použít abecedně seřazený slovník všech zaindexovaných slov.  Všechna
slova odpovídající dotazovanému prefixu sa dohledají vybráním všech slov mezi
prvním a posledním slovem s daným prefixem. Ty lze snadno dohledat dvěma
binárními vyhledáními. Dotaz je výpočetně náročnější při vykonání, protože se
nejprve musí provést sjednocení všech invertovaných seznamů odpovídajících
jednomu prefixu před tím, než se provede průnik.

Díky morfologii, která se vyskytuje hlavně na koncích slov, bude index
přizpůsobený pro prefixové vyhledávání vhodný zároveň i pro fuzzy vyhledávání.
Většina podobných slov bude v seřazeném slovníku blízko u sebe. Pokud
vyhledáváme přibližná slova do editovací vzdálenosti 1, pak několik slov se
bude lišit v prvním znaku od dotazovaného, ale většina rozdílů bude v
pozdějších částech slova, a tedy ve výsledku budou relativně blízko u sebe.


\subsubsection{Trie}
Pro rychlý průchod slovníkem s přibližným prohledáváním je vhodná datová
struktura \textbf{trie} (radixový, prefixový strom). Trie je n-ární stromová
struktura, ve které je každé slovo uloženo tak, že se nejprve rozloží na znaky
a ty se ve stejném pořadí uloží jako jedna cesta ve stromu. Např. slovo
\bftt{motorka} by se ve stromu uložilo jako cesta \bftt{/m/o/t/o/r/k/a} od
kořene \bftt{/}, pokud bychom příklad přirovnali k hierarchii adresářů a
souborů v souborovém systému.

Trii je možné komprimovat (komprimovaná trie, compressed trie) sloučením po
sobě jdoucích znaků, které mají pouze jednoho potomka. Např. pokud existují
pouze dvě slova \bftt{motorka} a \bftt{motýl}, pak jejich cesty ve stromu
budou \bftt{/mot/orka} a \bftt{/mot/ýl} a budou sdílet prefix \bftt{/mot/}.
Je to vlastně seřazený seznam slov s tím, že všechny společné prefixy jsou
uloženy jako rodičovské uzly stromu n-árního stromu. Tohle rozložení nám umožní
rychle dohledat prefix, jehož potomci ve stromu jsou odpovědí na prefixový
dotaz.

Vyhledání podobných slov podle editovací vzdálenosti využije společných prefixů
tím, že společný prefix spočítá pouze jednou pro celou skupinu slov. (cite
Hanov).

\subsubsection{Jiné reprezentace slovníku}
\paragraph{Metrické stromy}
% describe BK, VP-TREE
\paragraph{Delete algoritmus}
\paragraph{Signature hashing}

\subsubsection{Hybridní index}
Velkou výpočetní zátěží u prefixových a fuzzy indexů je, pokud musí provést
disjunktivní sloučení (sloučení, OR) většího množství invertovaných seznamů.
Většinou v literatuře potkáme konjunktivní sloučení (průnik, AND), které je
naopak tím efektivnější, čím více invertovaných seznamů v něm učinkuje.
Analogicky ke konjunkci množin - čím více náhodných množin, tím menší je
pravděpodobnost, že bude jejich prvek ve všech najednou. U disjunkce platí, že
čím více množin, tím bude sloučená množina zpravidla větší.

Sloučení invertovaných seznamů je problém, pokud jejich množství narůstá.
Zejména to platí pro krátké prefixy, protože ve slovníku k nim budou
korespondovat tisíce slov. Problém velkého množství slov u krátkých prefixů je
i u hranových ngramů, jenže u nich jsou invertované seznamy předsloučeny během
indexování. Právě zde přichází myšlenka hybridního indexu, který během
indexování spolu předsloučí ty invertované seznamy, které mají velkou šanci, že
by byly sloučeny během vykonání dotazu (materializace invertovaných seznamů).
Tahle technika je obzvlášť vhodná pro čistě prefixové indexy bez fuzzy
rozšíření. Velkou pravděpodobnost sloučení totiž mají slova, která jsou
abecedně blízko sebe.

Pokud je index rozšířený o pozicovou informaci, pak sloučením všech
invertovaných záznamů získáme zpět původní datovou sadu, pouze zakódovanou
(dopředný index, forward index). Index se nazývá hybridní, protože je hybridem
mezi invertovaným a dopředným indexem.

\paragraph{HYB} je typ hybridního invertovaného indexu, který během
indexování předsloučí invertované seznamy slov v abecedním rozsahu.
Materializované seznamy mohou mít rozsahy např. \bftt{[A-EN], [EN-NUL],
[NUL-QU], [QU-Z]} - první invertovaný seznam by obsahoval slova
začínající na \bftt{A} až \bftt{EN}. Disjunktivní dotaz v téhle
struktuře je už buďto předsloučený, nebo během vykonání dotazu za běhu
sloučí pouze malé množství sousedících materializovaných seznamů. Ke
každému záznamu ve sloučeném seznamu musí být poznamenáno, ke kterému
slovu patří. Dotazy, které nevyužijí celý rozsah seznamu se díky této
dodatečné informaci vyfiltrují od slov, které zúženému rozsahu
neodpovídají. cite completesearch.

\section{Ohodnocovací funkce}
\subsubsection{tf-idf}
\subsubsection{Blízkost}



\chapter{Návrh nového systému}
\section{Podpora v existujících systémech}
\subsubsection{Apache Lucene}
% lucene, elastic, solr, algolia, xapian, mnogosearch, postgres



\subsubsection{Indexace}
% 2-pass hybrid

\section{Ohodnocení výsledků dotazu}
\subsubsection{tf-idf}
% SEO - exploit of google's algorithms. Více vyhledávačů ztěžuje SEO
\subsubsection{Proximity}
% kritika tf-idf
% alternativa proximity


\chapter{Analýza}
\section{Implementované systémy}
Pro demonstraci uvedených technik jsem vytvořil tři vyhledávací systémy. První
z nich je má implementace hybridního indexu a zbylé dva jsou různé konfigurace
pro Elasticsearch sloužící k porovnání. Všechny porovnávané systémy odstraňují
diakritiku a převádějí velká písmena na malá při indexování i dotazování.
Všechny konfigurace jsou přiložené v \ref{appendix:search_config}.

\subsubsection{Naivní řešení}
Jako základní řešení sloužící pro porovnání jsem nakonfiguroval Elasticsearch
tak, jak by se měl doporučeně nastavit pro full-textové vyhledávání ve větších
textových dokumentech. Text je stematizován zabudovaným stematizérem pro
češtinu. Cílem bude ukázat, že tohle nastavení bude mít potíže s vícejazykovou
datovou sadou, jmény a s některými případy morfologie v češtině.

\subsubsection{Trigramový vyhledávač}
Pro ukázku fuzzy vyhledávání pomocí ngramů jsem vytvořil další konfiguraci pro
Elasticsearch, která používá ngramy o minimální a maximální velikosti 3.

Pokud se použije ngramový filtr, pak není podporováno ngramové zvýrazňování
výsledků. Musí se použít ngramový tokenizér, který ale zahazuje všechny ngramy,
které jsou kratší než minimální délka ngramu. Řešením je vytvořit dodatečný
index se zahozenými krátkými slovy a při dotazování provést disjunkci
ngramového a tohoto indexu. Pro zpřesnění výsledků, pokud dojde k přesné shodě
slova v dotazu a v dokumentu, je do disjunkce přidán ještě třetí index s
původními neořezanými slovy.

Zvýrazňovač pro ngramy funguje, pouze pokud se použije \textit{Fast Vector
Highlighter}. Bohužel nezvýrazňuje správně, když se ngramy ve výsledku
překrývají. Je možné, že je chyba pouze ve verzi Elasticsearch, kterou
používám. Protože jsem nikde nenašel, jak tohle vyřešit, vytvořil jsem v
Pythonu dodatečný zvýrazňovač, aby zde prezentované výsledky byly srovnatelné s
ostatními systémy.

\subsubsection{Moje implementace}
Můj systém vychází z výše popsaného návrhu vyhledávacího systému. Implementace
je pouze prototyp napsaný v dynamicky typovaném Pythonu, a tedy nemůže z
výkonostního důvodu sloužit k porovnání rychlosti a jiných výkonnostních
veličin. Protože ale používám relativně malé datové sady, neměla by být
výkonnost překážkou. Prototyp slouží zejména jako demonstrace implementovaných
technik. Tou hlavní je výše popsaný modifikovaný hybridní invertovaný index se
slovníkem implementovaným jako trie. Ohodnocovací funkce je čistě textově
založená - nemá o datech žádné vlastní předpoklady nebo přednostní pořadí. V
první řadě upřednostňuje shodu dotazu s výsledkem podle editační vzdálenosti -
pro každé slovo zvlášť. Dále pozitivně hodnotí ty výsledky, které obsahují
shodu s minimální poziční vzdáleností. Shody výsledků se stejným ohodnocením
jsou pak rozbity několika minoritními hodnotami s nízkou váhou. Shoda, která je
více na začátku záznamu má přednost a shoda, která obsahuje více shodujících se
slov má přednost - obdobně jako u modelu tf-idf, pouze zde má velmi malou váhu
a neuvažuje relativní důležitost slova ve shodě (idf).

Dokonce při použití nového interpreteru pro Python s podporou JIT
kompilace PyPy vyhledávač dosahuje až srovnatelných rychlostí jako
Elasticsearch.


\section{Použité datové soubory}
Cílem je porovnat několik vyhledávačů na datových sadách s relativně krátkými
dokumenty, které mají navíc různé záludnosti jako výce jazyků, nebo slova
obtížně zpracovatelná jazykovou analýzou.

\subsubsection{Databáze filmů - ČSFD}
První datovou sadou jsou názvy filmů z Československé filmové databáze
(\url{http://csfd.cz}). Přestože je možné rozlišit jazyk filmu, protože
databáze tuto metainformaci obsahuje, sloučil jsem všechny názvy filmů
do jedné sady. V datové sadě se tedy film vyskytuje vícekrát, pokud má
více názvů.

V databázi je celkem \textbf{441\,173} filmů a k nim jsou přidány
alternativní názvy v jiných jazycích, kterých je dohromady dalších
\textbf{176\,266}.

\subsubsection{Databáze filmových tvůrců - ČSFD}
Druhá datová sada jsou všichni tvůrců (herců, režisérů, scénáristů,
apod.) pocházejících rovněž z databáze ČSFD. Celkem obsahuje
\textbf{240\,659} jmen.

\subsubsection{Databáze filmů - IMDB}

\subsubsection{Databáze produktů}
% TODO sežeň ju

%
%\begin{center}
%\begin{tabular}{lr}
%\textbf{jazyk/země} & \textbf{počet názvů filmů} \\
%\hline
%původní           & 441\,173  \\
%anglický          &  47\,196  \\
%USA               &  28\,981  \\
%Slovensko         &  13\,932  \\
%slovenský         &   9\,539  \\
%Japonsko          &   7\,477  \\
%Francie           &   7\,419  \\
%Německo           &   5\,783  \\
%Rusko             &   3\,344  \\
%Česko             &   3\,180  \\
%Kanada            &   2\,774  \\
%Itálie            &   2\,766  \\
%český             &   2\,159  \\
%Španělsko         &   1\,606  \\
%Finsko            &   1\,267  \\
%Austrálie         &   1\,171  \\
%Polsko            &   1\,061  \\
%Maďarsko          &      822  \\
%Čína              &      781  \\
%\end{tabular}
%\end{center}


\subsubsection{Databáze herců - ČSFD}


\section{Demonstrace hybridního indexu}
\section{Ukázka vyhledávání}

\chapter{Otevřené problémy a další postup}
\section{Integrace do existujících systémů}
\section{Statické a dynamické indexy}
% static: no locks and latches, compact data structures, cache efficient
% 2 level data structure + bulk updates
\section{Škálovatelnost}
% columnar storage
% document or term based
% share nothing
\section{Příliš krátký vstupní řetězec}
\section{Plánování dotazů}


\chapter{Závěr}
Záměrem této práce je poukázat na alternativní přístupy v oblasti vyhledávání a
demonstrovat možný vyhledávací systém s alternativními technikami, který by byl
pro současné firemmní i nekomerční potřeby vhodnější, než systémy navrhované a
tvořené pro potřeby Webových vyhledávačů, které jsou však dnes nejrozšířenější.

\section*{Odkazy}
\url{http://www.dcs.gla.ac.uk/~craigm/publications/lacour08efficiency.pdf}

\newpage
\section*{Reference}
\bibliographystyle{csplainnat}
\bibliography{ref}

\appendix
\chapter{Konfigurace porovnaných systémů} \label{appendix:search_config}
jo


\backmatter


\end{document}
